1.1.	Написать скрипт определяющий запущен ли скрипт пользователем root.
       
        #!/bin/bash
        if [ $(id -u) = 0 ]
        then 
            echo "You are root"
            exit
        fi


1.2.	Написать скрипт который после запуска ожидает ввод строи от пользователя, а затем выводит ее в стандартный вывод. Используйте команду read.

        #!/bin/bash
        read user_input
        echo "Your input: $user_input"


1.3.	Написать скрипт который после запуска ожидает ввод строи от пользователя, а затем выводит ее в стандартный вывод, но ограничить время ожидания пользовательского ввода 5 секундами. В случае если пользователь не успел ввести строку, остановить программу и напечатать в стандартный вывод сообщение об этом.



        #!/bin/bash

        read -t 5 -p "You have 5 seconds. Your input: " user_input

        if [ -z "$user_input" ]
        then
            echo -e "\n5 seconds are over"
        else
            echo "$user_input"
        fi




1.4.	Напишите скрипт, возвращающий
1) количество дней, прошедших с начала года 

        #!/bin/bash
        echo "К-ство дней, прошедших с начала года: `date +%j`"


2) количество секунд, прошедших с начала "эпохи UNIX".

        #!/bin/bash
        echo "К-ство секунд прошедших с начала эпохи Unix: `date +%s`"


1.5.	Написать скрипт, который выводит в стандартный вывод все аргументы который были ему переданы. Используйте команду shift.

        
        #!/bin/bash
        count=1
        while [ -n "$1" ]
        do
        echo "Parameter #$count = $1"
        count=$(( $count + 1 ))
        shift
        done



1.6.	Напишите скрипт который ожидает пользовательского ввода одного символа с клавиатуры, проверяет что символ был введен один. Далее скрипт определяет что за символ был введен - буква в нижнем регистре, буква в верхнем регистре, цифра, знак пунктуации, пробел или что-то другое. Испольйте команду case.

        #!/bin/bash

        read -n 1 input_symbol

        echo -e "\n $input_symbol"

        case "$input_symbol" in
                [a-z]) echo "буква в нижнем регистре";;
                [A-Z]) echo "буква в верхнем регистре";;
                [0-9]) echo "Цифра";;
                *    ) echo "Знак пунктуации, пробел или что-то другое";;
        esac


1.7.	Написать скрипт преобразующий метры в мили. В качестве входящего аргумента должна быть цифра - метры. В стандартный вывод вывести количество миль.


        #!/bin/bash

        metrs=$1
        echo "skale=4;$metrs*0.00062137" | bc

1.8.	Напишите скрипт который будет проводить симуляцию 700 бросков 6 гранного кубика. Вывод должен быть в следующем формате:
echo "единиц   =   $ones"
echo "двоек    =   $twos"
echo "троек    =   $threes"
echo "четверок =   $fours"
echo "пятерок  =   $fives"
echo "шестерок =   $sixes"




        #!/bin/bash


        ones=0
        twos=0
        threes=0
        fours=0
        fives=0
        sixes=0

        for (( i=1; i <= 700; i++ ))
        do
        case $(( (RANDOM % 6) + 1 )) in

                1)ones=$((ones+1));;
                2)twos=$((twos+1));;
                3)threes=$((threes+1));;
                4)fours=$((fours+1));;
                5)fives=$((fives+1));;
                6)sixes=$((sixes+1));;
        esac

        done
        echo "единиц   =   $ones"
        echo "двоек    =   $twos"
        echo "троек    =   $threes"
        echo "четверок =   $fours"
        echo "пятерок  =   $fives"
        echo "шестерок =   $sixes"




1.2.1. Написать скрипт, который рандомно сгенерирует на диске структуру файлов и папок. Входным параметром будут: директория, в которой нужно генерировать данные, глубину вложенности поддиректорий, максимальный размер файлов, которые будут создаваться в этих директориях и максимальное количество итераций по созданию объектов в директории (т.е. общее количество файлов и директорий, которые будут созданы). Максимальная длина имени - 8 символов, содержимое файлов - рандом или нули. Проверку на доступное место делать не нужно.


1.2.2. Написать скрипт, который принимает 2 входных параметра: source_dir и destination_dir - две директории на диске, сравнивает, что они ни одна из них не является родительской для другой, у них не совпадают имена и т.п. Далее скрипт должен подсчитать место, занимаемое source_dir, и место, доступное на диске, где находится директория destination_dir, если есть доступное место - скопировать (с наследованием всех атрибутов: времени создания, доступа и модификации, владельца и т.п.), если места нет - вывести предупреждение на экран и предложить пользователю продолжить (C или Y) или прервать (N или A).


1.2.3. Модернизировать скрипт, чтобы он упаковывал данные из source_dir и складывал в destination_dir. При этом в самом начале работы скрипта нужно предусмотреть диалог с пользователем: предложить дописывать текущую дату и время в формате YYMMDD_HHSS.gz к имени файла или выполнять ротацию архивов, т.е. дописывал порядковый номер архива (0.gz, 1.gz, 2.gz). В случае выбора второго варианта - так же нужно запросить максимальное количество копий, при этом номер 0 присваивается самому последнему созданному архиву, а номер N-1 - самому старому, на каждой итерации архив с номером N - удаляется.


1.2.4. Модернизировать скрипт, чтобы все сообщения об ошибках подавлялись, а стандартные - выводились на консоль + записывались в лог-файл в текущей директории с именем out_YYMMDD_HHSS.log. Т.к. сообщения об ошибках подавляются, то в случае возникновения ошибок в процессе работы скрипта (проблемы с пермишенами, нехватка места, отсутствие какой-либо утилиты и т.п.) необходимо в конце работы скрипта вывести сообщение в консоль красным цветом "Warning: X error(s) occurred!", где X - количество перехваченных ошибок или количество вызовов команд, которые повлекли ошибки (как удобнее, на выбор).
